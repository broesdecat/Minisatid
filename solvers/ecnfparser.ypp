//%require "2.4.2"
%defines

//%skeleton "lalr1.cc"
//%language "c++"

//%code requires{
//temporarily, can just ensure that anytime the parser is included, vector etc has already been included.
%{
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <vector>
#include <list>
#include <map>

#include <tr1/memory>
using namespace std;
using namespace std::tr1;

#include "solvers/ExternalInterface.hpp"

//}

//%code{
	
extern ECNF_mode modes;
extern int 		yylex(void);
extern char * 	yytext;

void yyerror(const char* msg);
	
bool negatemod = false;
int cnfcurrentmodid = 0;
Atom cnfcurrenthead(-1);
vector<int> modalops;
vector<Literal> heads;

//Auxiliary variables, used while parsing.
int lineNo = 1;
int charPos = 1;

bool unsatfound = false;

shared_ptr<PropositionalSolver>	solver;
shared_ptr<ModalSolver>	modsolver;

AggrType getAggrType(int type);
MINISAT::EqType getRelType(int type);

/**
 * CR-CheckResult: checks the result of passing some data to the solvers.
 * The result is false if unsat was already detected.
 */
void CR(bool result);

void initSolver();
void initModSolver();

int atoms, clauses;

void finishCNFHeader();
void readCNFModalHierLevel(bool existential, vector<Atom>& rigidatoms);
shared_ptr<SolverInterface> getData();

%}

//for a reentrant parser, you need to use %pureparser

%union {
	int integer;
    bool boolean;
    vector<int>* vints;
    vector<Literal>* vlits;
    vector<LW>* vlws;
    vector<Atom>* vatoms;
    //MINISAT::EqType rel;
}

%token DISJUNCTION CONJUNCTION
%token SUBSETMINDEFN MNMZDEFN SUMMINDEFN
%token SETDEFN WSETDEFN  
%token <integer> ZERO NUMBER AGGDEFN REL
%token <boolean> SEMDEFN SIGNDEFN QUANTe
%token CNF ECNF MECNF DEFPRESENT AGGPRESENT MNMZPRESENT MODDEFN
%token INTVAR SUMTRT SUMTRI SUMTIRT SUMTIRI COUNTTRI COUNTTRT DISTINCT DELIM BINCONSTR

%type <integer> number posnumber
%type <vints> ibody
%type <vlits> body
%type <vlws> wbody
%type <vatoms> vbody

%destructor { delete $$; } vbody wbody ibody body

%start init

%%


/*
 * Decides whether to use (modal) CNF, ECNF or modal ECNF format
 */
init	:	CNF	number number { atoms = $2; clauses = $3; } cnftheory
		|	ECNF header {initSolver();} ecnftheory
		|	MECNF header {initModSolver();} mecnftheory
		;

header	: 	/*empty*/
		| 	header DEFPRESENT	{ modes.def = true;}
		| 	header AGGPRESENT	{ modes.aggr = true; }
		| 	header MNMZPRESENT	{ modes.mnmz = true; }
		;
		
//---------------------------------------------		
// CNF THEORY	
//---------------------------------------------
		
cnftheory	
		: 	modalcnf { finishCNFHeader(); } cnfclause
		;

modalcnf	
		:	/* empty */
		|	modalcnf QUANTe vbody ZERO { readCNFModalHierLevel($2, *$3); delete $3;} 
		;

//FIXME: onderstaande hielp voor betere performance, geen idee waarom
//cclauses:	/* empty */
//		|	cclauses cclause
//		;
			
cnfclause	
		: /*empty*/
		| cnfclause body ZERO	
			{	if(modsolver.get()!=NULL){
					CR(modsolver->addClause(cnfcurrentmodid, *$2)); delete $2;
				}else{
					CR(solver->addClause(*$2)); delete $2;
				}
			}
		;
			
//---------------------------------------------		
// ECNF THEORY	
//---------------------------------------------

ecnftheory	:	/* empty */
			|	ecnftheory clause
			|	ecnftheory rule
			| 	ecnftheory agg
			|	ecnftheory set
			|	ecnftheory wset
			|	ecnftheory mnmz
			|	ecnftheory subsetmnmz
			|	ecnftheory summnmz
			|	ecnftheory intvar
			|	ecnftheory cpconstraint
			;
			
mnmz	:	MNMZDEFN body ZERO				{ CR(solver->addMinimize(*$2, false)); delete $2;}
subsetmnmz: SUBSETMINDEFN body ZERO 		{ CR(solver->addMinimize(*$2, true)); delete $2;}
summnmz :	SUMMINDEFN NUMBER NUMBER ZERO	{ CR(solver->addSumMinimize(Atom($2), $3));}
		
clause	:	body ZERO	{ CR(solver->addClause(*$1)); delete $1; }
		;
rule	:	SEMDEFN NUMBER body ZERO  	{ CR(solver->addRule(!$1, Literal($2), *$3)); delete $3; }
		;
agg		:	AGGDEFN SEMDEFN SIGNDEFN NUMBER NUMBER NUMBER ZERO	{ CR(solver->addAggrExpr(Literal($4), $5, Weight($6), $3, getAggrType($1), $2)); }
		;
agg		:	AGGDEFN SEMDEFN SIGNDEFN NUMBER NUMBER ZERO ZERO	{ CR(solver->addAggrExpr(Literal($4), $5, Weight(0), $3, getAggrType($1), $2)); }
		;

set		:	SETDEFN NUMBER body ZERO	
				{ 
					CR(solver->addSet($2, *$3));
					delete $3;
				}
		;

wset	:	WSETDEFN NUMBER	wbody ZERO	
				{
					CR(solver->addSet($2, *$3));
					delete $3;
				}
		;

//---------------------------------------------		
// ECNF CONSTRAINT SUPPORT	
//---------------------------------------------

intvar	:	INTVAR number number number ZERO { solver->addIntVar($2, $3, $4); }
		;

cpconstraint
		:	BINCONSTR NUMBER number REL number ZERO { solver->addCPBinaryRel(Literal($2), $3, getRelType($4), $5); }
		|	SUMTRI NUMBER ibody REL number ZERO {solver->addCPSumVar(Literal($2), *$3, getRelType($4), $5); delete $3; }
		;

//		
//intlist :  /* empty */
//		|  intlist NUMBER
//			{ 
//				nb.push_back($2); 
//			}
//		;
//
//cpconstraint	:	/*SUMTRT NUMBER termlist REL NUMBER ZERO {solver->addSum($2, $3, $4, $5);}
//				|	SUMTRI NUMBER termlist REL number ZERO {solver->addSumVar($2, $3, $4, $5);}
//				|	SUMTIRT NUMBER termlist DELIM intlist REL NUMBER ZERO {solver->addSum($2, $3, $5, $6, $7);}
//				|	SUMTIRI NUMBER termlist DELIM intlist REL number ZERO {solver->addSumVar($2, $3, $5, $6, $7);}
////				|	COUNTTRI termlist REL number ZERO
//				|	COUNTTRT termlist DELIM number REL NUMBER ZERO { solver->addCount($2, $4, $5, $6); }
////				| 	DISTINCT termlist REL ZERO { solver->addDistinct($2 $3); }*/
//				;


			
//---------------------------------------------		
// MECNF THEORY	
//---------------------------------------------

mecnftheory	:	mhier mrest
			;

mhier	:	/* empty */
		|	mhier matomset
		|	mhier modhier
		;
		
mrest	: 	/* empty */
		|	mrest mclause
		|	mrest mrule
		| 	mrest magg
		|	mrest mset
		|	mrest mwset
		;
			
			
//MODAL PART: USES INDEXES+1 AS MODAL IDs IN THE THEORY
	//FIXME: probleem gevonden: de HEAD kan niet correct aan de juiste worden toegevoegd, 
	//want de parent is nog niet gekend! => ALLE MODS MOETEN EERST IN DE THEORIE!!!
	//FIXME 2: je kan nu vars enzo toevoegen terwijl de kinderen van een mod op nog niet gekend
	//zijn, wat dus onvolledige kennis geeft!
modhier :	MODDEFN	NUMBER NUMBER NUMBER ZERO 
				{ CR(modsolver->addChild($2-1, $3-1, Literal($4))); }
		;

matomset:	QUANTe NUMBER vbody ZERO 
				{ 
					if(!$1){
						throw idpexception("Forall quantifiers are not part of the chosen input format.\n");
					}
					modsolver->addAtoms($2-1, *$3); delete $3;
				}
		;
mclause	:	NUMBER body ZERO { CR(modsolver->addClause($1-1, *$2)); delete $2; }
		;
mrule	:	SEMDEFN NUMBER NUMBER body ZERO  { CR(modsolver->addRule($2-1, !$1, $3, *$4)); delete $4; }
		;
			
/*
 * bool 	addAggrExpr		(int modid, int head, int setid, Weight bound, bool lower, AggrType type, bool defined);
 * SUMDEFN  NUMBER SEMDEFN SIGNDEFN NUMBER NUMBER NUMBER ZERO
 * type		modid 	defined lower    head	setid	bound
 * addAggrExpr($2-1, $5, $6, Weight($7), $4, type, $3)
 */
			
magg	:	AGGDEFN  NUMBER SEMDEFN SIGNDEFN NUMBER NUMBER NUMBER ZERO	{ CR(modsolver->addAggrExpr($2-1, Literal($5), $6, Weight($7), $4, getAggrType($1), $3)); }
		;
magg	:	AGGDEFN  NUMBER SEMDEFN SIGNDEFN NUMBER NUMBER ZERO ZERO	{ CR(modsolver->addAggrExpr($2-1, Literal($5), $6, Weight(0), $4, getAggrType($1), $3)); }
		;

mset	:	SETDEFN NUMBER NUMBER body ZERO	
				{
					vector<Weight> weights;
					for(vector<Literal>::size_type i=0; i<(*$4).size(); i++){
						weights.push_back(1);
					}
					CR(modsolver->addSet($2-1, $3, *$4, weights));
					delete $4;
				}
		;

mwset	:	WSETDEFN NUMBER NUMBER wbody ZERO	
				{ 
					CR(modsolver->addSet($2-1, $3, *$4));
					delete $4;
				}
		;
			

//---------------------------------------------		
// GENERAL RULES
//---------------------------------------------
			
body	:	body NUMBER { $$ = $1; $$->push_back(Literal(abs($2), $2<0));	}
		|				{ $$ = new vector<Literal>();	}
		;
		
wbody	:	wbody NUMBER REL number	
				{ 
					if(getRelType($3)!=MINISAT::MEQ) { 
						throw idpexception("Weighted sets can only contain tuples with equality"); 
					} 
					$$ = $1; $$->push_back(LW(Literal(abs($2), $2<0), Weight($4)));	
				}
		|	NUMBER REL number		
				{ 
					if(getRelType($2)!=MINISAT::MEQ) {
						throw idpexception("Weighted sets can only contain tuples with equality"); 
					} 
					$$ = new vector<LW>(1,LW(Literal(abs($1), $1<0), Weight($3)));	
				}	
		;
		
vbody	:	vbody posnumber { $$ = $1; $$->push_back(Atom(abs($2)));	}
		|	posnumber		{ $$ = new vector<Atom>(1,Atom(abs($1)));	}	
		;
		

ibody 
		: ibody number	{ $$ = $1; $$->push_back($2);	}
		| number  		{ $$ = new vector<int>(1, $1);	}
		;
				
posnumber
		: NUMBER 
			{ 
				if($1<=0){
					throw idpexception("Expecting a list of natural numbers larger than zero.");
				}
				$$ = $1;
			}
		;
			
number	:	NUMBER	{ $$ = $1; }
		|	ZERO	{ $$ = 0; }

%%

int yywrap() {
	cerr << "End of file reached before it was expected... bailing out." << endl;
	return 1;
}

void yyinit(){ }

void yydestroy(){
	solver.reset();
	modsolver.reset();
	heads.clear();
	modalops.clear();
}

// If an unforeseen parse error occurs, it calls this function (e.g. with msg="syntax error")
void yyerror(const char* msg) {
	if(unsatfound){
		throw idpexception(msg);
	}else{
		cerr << "Parse error: ";
		cerr << "Line " << lineNo << ", column " << charPos << ": "; 
		cerr << msg;
		if (strlen(/*ecnftext*/yytext)){
			cerr << " on \"" << /*ecnftext*/yytext << "\"";		
		}
		cerr << endl;
		throw idpexception(msg);
	}	
}

AggrType getAggrType(int type){
	return static_cast<AggrType>(type);
}

MINISAT::EqType getRelType(int type){
	return static_cast<MINISAT::EqType>(type);
}


/**
 * CR-CheckResult: checks the result of passing some data to the solvers.
 * The result is false if unsat was already detected.
 */
void CR(bool result){
	if(!result){
		unsatfound = true;
		yyerror("Unsat was found during parsing.\n");
	}		
}

void initSolver(){
	solver = shared_ptr<PropositionalSolver>(new PropositionalSolver(modes));
}

void initModSolver(){
	modsolver = shared_ptr<ModalSolver>(new ModalSolver(modes));
}

shared_ptr<SolverInterface> getData(){
	if(solver.get()!=NULL){
		return solver;
	}else{
		return modsolver;
	}
}

void readCNFModalHierLevel(bool existential, vector<Atom>& rigidatoms){
	bool writeexists;
	if(existential && negatemod){
		negatemod = false;
		writeexists = false;
	}else if(existential && !negatemod){
		negatemod = false;
		writeexists = true;
	}else if(!existential && negatemod){
		negatemod = true;
		writeexists = true;
	}else{
		negatemod = true;
		writeexists = false;
	}
	if(modsolver.get()==NULL && solver.get()==NULL){
		initModSolver();
		cnfcurrenthead = atoms;
	}else{
		modalops.push_back(cnfcurrentmodid);
		if(writeexists){
			heads.push_back(Literal(cnfcurrenthead, false));
		}else{
			heads.push_back(Literal(cnfcurrenthead, true));
		}
		cnfcurrentmodid++;
		CR(modsolver->addChild(cnfcurrentmodid-1, cnfcurrentmodid, Literal(cnfcurrenthead)));
		modsolver->addAtoms(cnfcurrentmodid, rigidatoms);
		if(rigidatoms.size()!=0){
			throw idpexception();
		}
		cnfcurrenthead = Atom(cnfcurrenthead.getValue());
	}
}

void finishCNFHeader(){
	if(modsolver.get()==NULL && solver.get()==NULL){ //plain cnf
		initSolver();
	}else{ //modal cnf
		if(negatemod){
			throw idpexception(
					"The quantifiers require to negate the full theory, this is "
					"not handled at the moment.\n"
					);
		}
		for(vector<int>::size_type i = 0; i<modalops.size(); i++){
			vector<Literal> lits;
			lits.push_back(heads[i]);
			CR(modsolver->addClause(modalops[i], lits)); lits.clear();	
		}
	}
}
