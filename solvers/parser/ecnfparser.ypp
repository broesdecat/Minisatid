//%require "2.4.2"

//does not seem to have the same effect as adding it to the makefile
//%defines

//%skeleton "lalr1.cc"
//%language "c++"

//%code requires{
//temporarily, can just ensure that anytime the parser is included, vector etc has already been included.
%{
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <vector>
#include <list>
#include <map>

#include "solvers/utils/Utils.hpp"
#include "solvers/external/ExternalInterface.hpp"

//}

//%code{
	
extern ECNF_mode modes;
extern int 		yylex(void);
extern char * 	yytext;

void yyerror(const char* msg);
	
bool negatemod = false;
int cnfcurrentmodid = 0;
Atom cnfcurrenthead(-1);
vector<int> modalops;
vector<Literal> heads;

//Auxiliary variables, used while parsing.
int lineNo = 1;
int charPos = 1;

bool unsatfound = false;

tr1::shared_ptr<PropositionalSolver>	solver;
tr1::shared_ptr<ModalSolver>	modsolver;

/**
 * CR-CheckResult: checks the result of passing some data to the solvers.
 * The result is false if unsat was already detected.
 */
void CR(bool result);

void initSolver();
void initModSolver();

int atoms, clauses;

vector<Atom> rigidatoms; //a necessary list of accumulated rigid atoms when reading qbf format

void finishCNFHeader();
void readCNFModalHierLevel(bool existential, const vector<Atom>& rigidatoms);
shared_ptr<SolverInterface> getData();

%}

//for a reentrant parser, you need to use %pureparser

%union {
	int integer;
    bool boolean;
    vector<int>* vints;
    vector<Literal>* vlits;
    vector<LW>* vlws;
    vector<Atom>* vatoms;
    MINISAT::EqType rel;
    AggType aggr;
    AggSign sign;
    AggSem sem;
}

%token DISJUNCTION CONJUNCTION
%token SUBSETMINDEFN MNMZDEFN SUMMINDEFN
%token SETDEFN WSETDEFN  
%token <integer> ZERO NUMBER
%token <sem> SEMDEFN <sign> SIGNDEFN QUANTe
%token <rel> REL
%token <aggr> AGGDEFN
%token CNF ECNF MECNF DEFPRESENT AGGPRESENT MNMZPRESENT MODDEFN CPPRESENT
%token INTVAR SUMSTRT SUMSTRI SUMSTSIRT SUMSTSIRI COUNTSTRIT DISTINCT DELIM BINTRI BINTRT
%token FORCECHOICE

%type <integer> number posnumber
%type <vints> ibody
%type <vlits> body
%type <vlws> wbody
%type <vatoms> vbody

//Blijkt nog niet te werken, zal ook wel in een nieuwere versie zijn
//%destructor { delete $$; reportf("DELETED.\n"); } vbody wbody ibody body

%start init

%%


/*
 * Decides whether to use (modal) CNF, ECNF or modal ECNF format
 */
init	:	CNF	number number 
				{ atoms = $2; clauses = $3; reportf("%d atoms and %d clauses present.\n", atoms, clauses);} 
			cnftheory
		|	ECNF header {initSolver();} ecnftheory
		|	MECNF header {initModSolver();} mecnftheory
		;

header	: 	/*empty*/
		| 	header DEFPRESENT	{ modes.def = true;}
		| 	header CPPRESENT	{ modes.cp = true;}
		| 	header AGGPRESENT	{ modes.aggr = true; }
		| 	header MNMZPRESENT	{ modes.mnmz = true; }
		;
		
//---------------------------------------------		
// CNF THEORY	
//---------------------------------------------
		
cnftheory	
		: 	modalcnf { finishCNFHeader(); } cnfclause
		;

modalcnf	
		:	/* empty */
		|	modalcnf QUANTe  
				{ 	readCNFModalHierLevel($2, rigidatoms); }
			rigidvars ZERO //HAS TO first add new level with PREVIOUS rigid atoms before adding to them
		;
		
rigidvars
		:	rigidvars posnumber { rigidatoms.push_back(Atom(abs($2)));	}
		|	posnumber			{ rigidatoms.push_back(Atom(abs($1)));	}	
		;
			
cnfclause	
		: /*empty*/
		| 	cnfclause body ZERO	
				{	
					if(modsolver.get()!=NULL){
						CR(modsolver->addClause(cnfcurrentmodid, *$2)); delete $2;
					}else{
						CR(solver->addClause(*$2)); delete $2;
					}
				}
		;
			
//---------------------------------------------		
// ECNF THEORY	
//---------------------------------------------

ecnftheory	:	/* empty */
			|	ecnftheory FORCECHOICE body ZERO { solver->addForcedChoices(*$3); delete $3; }
			|	ecnftheory clause
			|	ecnftheory rule
			| 	ecnftheory agg
			|	ecnftheory set
			|	ecnftheory wset
			|	ecnftheory mnmz
			|	ecnftheory subsetmnmz
			|	ecnftheory summnmz
			|	ecnftheory intvar
			|	ecnftheory cpconstraint
			;
			
mnmz	:	MNMZDEFN body ZERO				{ CR(solver->addMinimize(*$2, false)); delete $2;}
subsetmnmz: SUBSETMINDEFN body ZERO 		{ CR(solver->addMinimize(*$2, true)); delete $2;}
summnmz :	SUMMINDEFN NUMBER NUMBER ZERO	{ CR(solver->addSumMinimize(Atom($2), $3));}
		
clause	:	body ZERO	
				{ 	CR(solver->addClause(*$1)); delete $1; }
		;

rule	:	SEMDEFN NUMBER body ZERO  
				{ 	CR(solver->addRule(!$1, Literal($2), *$3)); delete $3; }
		;

agg		:	AGGDEFN SEMDEFN SIGNDEFN NUMBER NUMBER number ZERO	
				{ 	CR(solver->addAggrExpr(Literal($4), $5, Weight($6), $3, $1, $2)); }
		;

set		:	SETDEFN NUMBER body ZERO	
				{ 	CR(solver->addSet($2, *$3)); delete $3;	}
		;

wset	:	WSETDEFN NUMBER	wbody ZERO	
				{	CR(solver->addSet($2, *$3)); delete $3;	}
		;

//---------------------------------------------		
// ECNF CONSTRAINT SUPPORT	
//---------------------------------------------

intvar	:	INTVAR number number number ZERO 
				{ 	CR(solver->addIntVar($2, $3, $4)); }
		;

/*intvarset
		:	INTVARSET number ibody ZERO 
				{ 	CR(solver->addIntVarSet($2, *$3)); delete $3; }
		;*/

//abbreviations: T = intterm, I = intconst, R = relational operator, ST = set of T, SI = set of I

cpconstraint
		:	BINTRI NUMBER number REL number ZERO 
				{ 	CR(solver->addCPBinaryRel(Literal($2), $3, $4, $5)); }
		|	BINTRT NUMBER number REL number ZERO 
				{ 	CR(solver->addCPBinaryRelVar(Literal($2), $3, $4, $5)); }
		|	SUMSTRI NUMBER ibody REL number ZERO 
				{ 	CR(solver->addCPSum(Literal($2), *$3, $4, $5)); delete $3; }
		|	SUMSTRT NUMBER ibody REL number ZERO 
				{ 	CR(solver->addCPSumVar(Literal($2), *$3, $4, $5)); delete $3; }
		|	SUMSTSIRI NUMBER ibody DELIM ibody REL number ZERO 
				{ 	CR(solver->addCPSum(Literal($2), *$3, *$5, $6, $7)); delete $3; delete $5; }
		|	SUMSTSIRT NUMBER ibody DELIM ibody REL number ZERO 
				{ 	CR(solver->addCPSumVar(Literal($2), *$3, *$5, $6, $7)); delete $3; delete $5; }
			//only global card at the moment!
		|	COUNTSTRIT ibody REL number number ZERO 
				{ 	CR(solver->addCPCount(*$2, $4, $3, $5)); delete $2; }
			//only global alldiff at the moment!
		|	DISTINCT ibody DELIM ZERO //DELIM to remove shift-reduce conflict 
				{ 	CR(solver->addCPAlldifferent(*$2)); delete $2; }
		;

//		
//intlist :  /* empty */
//		|  intlist NUMBER
//			{ 
//				nb.push_back($2); 
//			}
//		;
//
//cpconstraint	:	/*SUMTRT NUMBER termlist REL NUMBER ZERO {solver->addSum($2, $3, $4, $5);}
//				|	SUMTRI NUMBER termlist REL number ZERO {solver->addSumVar($2, $3, $4, $5);}
//				|	SUMTIRT NUMBER termlist DELIM intlist REL NUMBER ZERO {solver->addSum($2, $3, $5, $6, $7);}
//				|	SUMTIRI NUMBER termlist DELIM intlist REL number ZERO {solver->addSumVar($2, $3, $5, $6, $7);}
////				|	COUNTTRI termlist REL number ZERO
//				|	COUNTTRT termlist DELIM number REL NUMBER ZERO { solver->addCount($2, $4, $5, $6); }
////				| 	DISTINCT termlist REL ZERO { solver->addDistinct($2 $3); }*/
//				;


			
//---------------------------------------------		
// MECNF THEORY	
//---------------------------------------------

mecnftheory	:	mhier mrest
			;

mhier	:	/* empty */
		|	mhier matomset
		|	mhier modhier
		;
		
mrest	: 	/* empty */
		|	mrest mclause
		|	mrest mrule
		| 	mrest magg
		|	mrest mset
		|	mrest mwset
		;
			
			
//MODAL PART: USES INDEXES+1 AS MODAL IDs IN THE THEORY
//FIXME: probleem gevonden: de HEAD kan niet correct aan de juiste worden toegevoegd, 
//want de parent is nog niet gekend! => ALLE MODS MOETEN EERST IN DE THEORIE!!!
//FIXME 2: je kan nu vars enzo toevoegen terwijl de kinderen van een mod op nog niet gekend
//zijn, wat dus onvolledige kennis geeft!
modhier :	MODDEFN	NUMBER NUMBER NUMBER ZERO 
				{ 	CR(modsolver->addChild($2-1, $3-1, Literal($4))); }
		;

matomset:	QUANTe NUMBER vbody ZERO 
				{ 
					if(!$1){
						throw idpexception("Forall quantifiers are not part of the chosen input format.\n");
					}
					CR(modsolver->addAtoms($2-1, *$3)); delete $3;
				}
		;

mclause	:	NUMBER body ZERO 
				{	 CR(modsolver->addClause($1-1, *$2)); delete $2; }
		;

mrule	:	SEMDEFN NUMBER NUMBER body ZERO  
				{ 	CR(modsolver->addRule($2-1, !$1, $3, *$4)); delete $4; }
		;

magg	:	AGGDEFN  NUMBER SEMDEFN SIGNDEFN NUMBER NUMBER number ZERO	
				{ 	CR(modsolver->addAggrExpr($2-1, Literal($5), $6, Weight($7), $4, $1, $3)); }
		;

mset	:	SETDEFN NUMBER NUMBER body ZERO	
				{
					vector<Weight> weights;
					for(vector<Literal>::size_type i=0; i<(*$4).size(); i++){
						weights.push_back(1);
					}
					CR(modsolver->addSet($2-1, $3, *$4, weights));
					delete $4;
				}
		;

mwset	:	WSETDEFN NUMBER NUMBER wbody ZERO	
				{ 
					CR(modsolver->addSet($2-1, $3, *$4));
					delete $4;
				}
		;
			

//---------------------------------------------		
// GENERAL RULES
//---------------------------------------------
			
//Clausese can be empty!
body	:	body NUMBER { $$ = $1; $$->push_back(Literal(abs($2), $2<0));	}
		|				{ $$ = new vector<Literal>();	}
		;
		
wbody	:	wbody NUMBER REL 
				{ 
					if($3!=MINISAT::MEQ) { 
						throw idpexception("Weighted sets can only contain tuples with equality.\n");
					} 
				} 
			number	
				{ $$ = $1; $$->push_back(LW(Literal(abs($2), $2<0), Weight($5))); }
			
		|	NUMBER REL 
				{ 
					if($2!=MINISAT::MEQ) { 
						throw idpexception("Weighted sets can only contain tuples with equality.\n");
					} 
				} 
			number	
				{ $$ = new vector<LW>(1,LW(Literal(abs($1), $1<0), Weight($4))); }
		;
		
vbody	:	vbody posnumber { $$ = $1; $$->push_back(Atom(abs($2)));	}
		|	posnumber		{ $$ = new vector<Atom>(1,Atom(abs($1)));	}	
		;
		
ibody 	: 	ibody number	{ $$ = $1; $$->push_back($2);	}
		| 	number  		{ $$ = new vector<int>(1, $1);	}
		;
				
posnumber
		: NUMBER 
			{ 
				if($1<=0){
					throw idpexception("Expecting a positive number.\n");
				}
				$$ = $1;
			}
		;
			
number	:	NUMBER	{ $$ = $1; }
		|	ZERO	{ $$ = 0; }

%%

int yywrap() {
	cerr << "End of file reached before it was expected... bailing out.\n" << endl;
	return 1;
}

void yyinit(){ }

void yydestroy(){
	solver.reset();
	modsolver.reset();
	heads.clear();
	modalops.clear();
}

// If an unforeseen parse error occurs, it calls this function (e.g. with msg="syntax error")
//Should NOT be used any more: if an idpexception is thrown during parsing, even from deep within
//the code, the error handling will print the parsing position itself.
void yyerror(const char* msg) {
	throw idpexception(msg);
}

/**
 * CR-CheckResult: checks the result of passing some data to the solvers.
 * The result is false if unsat was already detected.
 */
void CR(bool result){
	if(!result){
		unsatfound = true;
		throw idpexception("Unsat during parsing.\n");
	}		
}

void initSolver(){
	solver = shared_ptr<PropositionalSolver>(new PropositionalSolver(modes));
}

void initModSolver(){
	modsolver = shared_ptr<ModalSolver>(new ModalSolver(modes));
}

shared_ptr<SolverInterface> getData(){
	if(solver.get()!=NULL){
		return solver;
	}else{
		return modsolver;
	}
}

void readCNFModalHierLevel(bool existential, const vector<Atom>& rigidatoms){
	assert(solver.get()==NULL);
	
	bool writeexists;
	if(existential && negatemod){
		negatemod = false;
		writeexists = false;
	}else if(existential && !negatemod){
		negatemod = false;
		writeexists = true;
	}else if(!existential && negatemod){
		negatemod = true;
		writeexists = true;
	}else{
		negatemod = true;
		writeexists = false;
	}
	if(modsolver.get()==NULL){
		initModSolver();		 
		cnfcurrenthead = Atom(atoms+1);
	}else{
		modalops.push_back(cnfcurrentmodid);
		if(writeexists){
			heads.push_back(Literal(cnfcurrenthead, false));
		}else{
			heads.push_back(Literal(cnfcurrenthead, true));
		}
		cnfcurrentmodid++;
		CR(modsolver->addChild(cnfcurrentmodid-1, cnfcurrentmodid, Literal(cnfcurrenthead)));
		modsolver->addAtoms(cnfcurrentmodid, rigidatoms);
		if(rigidatoms.size()==0){
			throw idpexception("List of rigid atoms is empty.\n");
		}
		cnfcurrenthead = Atom(cnfcurrenthead.getValue()+1);
	}
}

void finishCNFHeader(){
	if(modsolver.get()==NULL && solver.get()==NULL){ //plain cnf
		initSolver();
	}else{ //modal cnf
		if(negatemod){
			throw idpexception("The quantifiers require to negate the full theory, "
								"this is not handled at the moment.\n");
		}
		for(vector<int>::size_type i = 0; i<modalops.size(); i++){
			vector<Literal> lits;
			lits.push_back(heads[i]);
			CR(modsolver->addClause(modalops[i], lits)); lits.clear();	
		}
	}
}
