%{
/* C++ declarations: */
#include <iostream>

/*
 * Temporarily, until new bison is available
 * SHOULD BE REMOVED THEN
 */
#include <vector>
#include "solvers/utils/Utils.hpp"
using namespace std; 
//UP TILL HERE!

#include "solvers/parser/ecnfparser.h"

extern int lineNo;
extern int charPos;

#define ADJ (charPos += yyleng)
%}

/* lex definitions: */
%option noyywrap

%x TRANSLATION_MODUS
%%

^"c grounder error".*	{ throw MinisatID::idpexception("There was a grounding error, so no solving is possible.\n");}
^"c ".*		{/* disregard comments */}

^"p "	{ADJ; }
"cnf"	{ADJ; return CNF;}
"ecnf"	{ADJ; return ECNF;}
"mecnf"	{ADJ; return MECNF;}
"def" 	{ADJ; return DEFPRESENT;}
"aggr" 	{ADJ; return AGGPRESENT;}
"mnmz" 	{ADJ; return MNMZPRESENT;}
"cp" 	{ADJ; return CPPRESENT;}

"forcesearch" { ADJ; return FORCECHOICE; }

"WSet"	{ADJ; return WSETDEFN;}
"Set"	{ADJ; return SETDEFN;}
"Card"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::CARD; return AGGDEFN;}
"Sum"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::SUM; return AGGDEFN;}
"Prod"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::PROD; return AGGDEFN;}
"Min"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::MIN; return AGGDEFN;}
"Max"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::MAX; return AGGDEFN;}

"Mod"	{ADJ; return MODDEFN;}

"D"		{ADJ; /*ecnflval*/yylval.sem = MinisatID::DEF;  return SEMDEFN;}
"C"		{ADJ; /*ecnflval*/yylval.sem = MinisatID::COMP; return SEMDEFN;}
"L"		{ADJ; /*ecnflval*/yylval.sign = MinisatID::LB;  return SIGNDEFN;}
"G"		{ADJ; /*ecnflval*/yylval.sign = MinisatID::UB; return SIGNDEFN;}

"e"		{ADJ; /*ecnflval*/yylval.boolean = true; return QUANTe;} //existential quantifier
"a"		{ADJ; /*ecnflval*/yylval.boolean = false; return QUANTe;} //universal quantifier

"Mnmz"		{ADJ; return SUBSETMINDEFN;}
"Mnmt"     	{ADJ; return MNMZDEFN;}
"SumMnmz"	{ADJ; return SUMMINDEFN;}

" "		{ADJ; /* disregard whitespaces */}
"\t"	{ADJ; /*                       */}
"\n"	{charPos = 1; lineNo++; /*     */}

"|"	{ADJ; return DELIM;}

"INTVAR"	{ADJ; return INTVAR;}
"BINTRI"	{ADJ; return BINTRI;}
"BINTRT"	{ADJ; return BINTRT;}
"SUMSTRI"	{ADJ; return SUMSTRI;}
"SUMSTRT"	{ADJ; return SUMSTRT;}
"SUMSTSIRI"	{ADJ; return SUMSTSIRI;}
"SUMSTSIRT"	{ADJ; return SUMSTSIRT;}
"COUNTSTRIT"	{ADJ; return COUNTSTRIT;}

"="		{ADJ; /*ecnflval*/yylval.rel = MinisatID::MINISAT::MEQ; return REL;}
">"		{ADJ; /*ecnflval*/yylval.rel = MinisatID::MINISAT::MG; return REL;}
"<"		{ADJ; /*ecnflval*/yylval.rel = MinisatID::MINISAT::ML; return REL;}
"~="	{ADJ; /*ecnflval*/yylval.rel = MinisatID::MINISAT::MNEQ; return REL;}
"=<"	{ADJ; /*ecnflval*/yylval.rel = MinisatID::MINISAT::MLEQ; return REL;}
">="	{ADJ; /*ecnflval*/yylval.rel = MinisatID::MINISAT::MGEQ; return REL;}

 /* Longest match is returned -> if e.g. "20", NUMBER is returned.
    If "0", then ZERO is returned since it's the first matching rule.
  */
"0"			{ADJ; /*ecnflval*/yylval.integer = 0; return ZERO;}
-?[0-9]+	{ADJ; /*ecnflval*/yylval.integer = atoi(yytext); return NUMBER;}

<*>.		{/* Anything else: parse error */
				char s[100];
				sprintf(s, "Encountered unexpected character '%s'.\n", yytext);
				throw MinisatID::idpexception(s);
			}
