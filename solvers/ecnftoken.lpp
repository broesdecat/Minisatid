%{
/* C++ declarations: */
#include <iostream>

/*
 * Temporarily, until new bison is available
 * SHOULD BE REMOVED THEN
 */
#include <vector>
#include "solvers/solverfwd.hpp"
using namespace std; 
//UP TILL HERE!

#include "ecnfparser.h"

#include "solvers/solverfwd.hpp"

extern int lineNo;
extern int charPos;

#define ADJ (charPos += yyleng)
%}

/* lex definitions: */
%option noyywrap

%x TRANSLATION_MODUS
%%

^"c grounder error".*	{cerr << "There was a grounding error, so no solving is possible." << endl; 
						 throw idpexception();}
^"c ".*		{/* disregard comments */}

^"p "	{ADJ; }
"cnf"	{ADJ; return CNF;}
"ecnf"	{ADJ; return ECNF;}
"mecnf"	{ADJ; return MECNF;}
"def" 	{ADJ; return DEFPRESENT;}
"aggr" 	{ADJ; return AGGPRESENT;}
"mnmz" 	{ADJ; return MNMZPRESENT;}

"WSet"	{ADJ; return WSETDEFN;}
"Set"	{ADJ; return SETDEFN;}
"Card"	{ADJ; /*ecnflval*/yylval.integer = CARD; return AGGDEFN;}
"Sum"	{ADJ; /*ecnflval*/yylval.integer = SUM; return AGGDEFN;}
"Prod"	{ADJ; /*ecnflval*/yylval.integer = PROD; return AGGDEFN;}
"Min"	{ADJ; /*ecnflval*/yylval.integer = MIN; return AGGDEFN;}
"Max"	{ADJ; /*ecnflval*/yylval.integer = MAX; return AGGDEFN;}

"Mod"		{ADJ; return MODDEFN;}

"D"		{ADJ; /*ecnflval*/yylval.boolean = true;  return SEMDEFN;}
"C"		{ADJ; /*ecnflval*/yylval.boolean = false; return SEMDEFN;}
"L"		{ADJ; /*ecnflval*/yylval.boolean = true;  return SIGNDEFN;}
"G"		{ADJ; /*ecnflval*/yylval.boolean = false; return SIGNDEFN;}

"e"		{ADJ; /*ecnflval*/yylval.boolean = true; return QUANTe;} //existential quantifier
"a"		{ADJ; /*ecnflval*/yylval.boolean = false; return QUANTe;} //universal quantifier

"Mnmz"		{ADJ; return SUBSETMINDEFN;}
"Mnmt"     	{ADJ; return MNMZDEFN;}
"SumMnmz"	{ADJ; return SUMMINDEFN;}

" "		{ADJ; /* disregard whitespaces */}
"\t"	{ADJ; /*                       */}
"\n"	{charPos = 1; lineNo++; /*     */}

"BINCONST"	{ADJ; return BINCONSTR;}

"="		{ADJ; /*ecnflval*/yylval.integer = MINISAT::MEQ; return REL;}
">"		{ADJ; /*ecnflval*/yylval.integer = MINISAT::MG; return REL;}
"<"		{ADJ; /*ecnflval*/yylval.integer = MINISAT::ML; return REL;}
"!="	{ADJ; /*ecnflval*/yylval.integer = MINISAT::MNEQ; return REL;}
"=<"	{ADJ; /*ecnflval*/yylval.integer = MINISAT::MLEQ; return REL;}
">="	{ADJ; /*ecnflval*/yylval.integer = MINISAT::MGEQ; return REL;}

 /* Longest match is returned -> if e.g. "20", NUMBER is returned.
    If "0", then ZERO is returned since it's the first matching rule.
  */
"0"			{ADJ; /*ecnflval*/yylval.integer = 0; return ZERO;}
-?[0-9]+	{ADJ; /*ecnflval*/yylval.integer = atoi(yytext); return NUMBER;}

<*>.		{/* Anything else: parse error */
				cerr	<< "Line " << lineNo 
						<< ", Column " << charPos 
						<< ": Parse error (unexpected character '"
						<< yytext
						<< "' encountered)." 
						<< endl;
				throw idpexception();
			}
