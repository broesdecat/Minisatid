SMT PARADIGM
SAT SOLVER INTERFACE
void	addClause(vector<lits) 					//add a new clause, possibly created by T
Var	newVar( bool = true, bool = true )
  
TSOLVER INTERFACE
void 				init(vector<lits>) 	//init with all literals l usable/used by T
vector<lits>	explanation( Lit)		//returns the explanation for a deduced literal, valid under the clause learning hypothesis (return earlier explanation)                 
vector<lits>	settrue( lit )			//if conflict in T, throw inconsistency exception, otherwise return literals that are now implied (and not previously)
bool 	  			IsTrue(lit) 			//return true if it is implied by the theory
void				backtrack( n);			// Remove n literals from the T stack

when are they used:
when a literal is propagated to true, settrue is called
if this raises an exception
	 clause learning is done by satsolver, by querying explanation of T, then backtrack is called to the appropriate level
else
	any propagations made by T are done and used for further propagations
	
at any point, it can be checked whether some literal T has become implied by T

in the other direction, some new clauses, implied by the theory, might be generated by the T solver, which can then be added to the sat solver clauses, just like conflict clauses
also, at some point, the T solver might need extra variables, which can be created by newVar. They might be only used within T, or when a clause containing them is returned, the sat solver will also use them.

conflict-based analysis en clause learning




MINISAT ARCHITECTURE
SAT SOLVER INTERFACE
//heuristic
void 	dontRemoveSatisfiedClauses();

//sat solver assignments, for performance (decide where to backtrack to, ...)
int getLevel(int var) const;
Lit getRecentAssignments(int i) const;
int getNbOfRecentAssignments() const;

//current state of solver
lbool   value      (Var x) const;		// The current value of a variable.
lbool   value      (Lit p) const;		// The current value of a literal.
lbool   modelValue (Lit p) const;		// The value of a literal in the last model. The last call to solve must have been satisfiable.
int     decisionLevel()    const;		// Gives the current decisionlevel.
int     nVars      ()      const;		// The current number of variables.

//propagate new observations
void 		addLearnedClause(Clause* c);	//don't check anything, add it to clauses and bump activity
void 		addClause(Clause* c);			//don't check anything, add it to clauses

//backtrack
void		cancelUntil      (int level);								// Backtrack until a certain level.
//??
void		uncheckedEnqueue (Lit p, Clause* from = NULL);		// Enqueue a literal. Assumes value of literal is undefined.
//??
Clause*	propagate        ();											// Perform unit propagation. Returns possibly conflicting clause.
//??
bool 		existsUnknownVar(); 											//true if the current assignment is completely two-valued
//add new var also to the sat solver to decide upon
Var		newVar(bool polarity = true, bool dvar = false); 	// Add a new variable with parameters specifying variable mode.
	
TSOLVER INTERFACE FOR aggregates, arithmetic and definitions
//simplify T theory
bool 		simplify		();							//simplify the T theory
//backtrack
void 		backtrack 	( Lit l);					//backtrack lit l
//propagate changes
void 		setTrue	(Lit p, Clause* confl);
//explain conflicts
Clause* 	getExplanation	(Lit p);
//datastructure management
void 		notifyVarAdded			(); 				//correctly initialized TSolver datastructures when vars are added

//void Subsetminimize(const vec<Lit>& lits);

