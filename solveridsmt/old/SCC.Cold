/*
 * SCC.C
 *
 *  Created on: Jan 19, 2010
 *      Author: broes
 */

#include "SCC.h"

SCC::SCC(IDSolver& s, vec<Lit>& (IDSolver::*getChildren)(), bool (IDSolver::*isValidChild)(Lit), int (IDSolver::*nNodes)()):idsolver(s){
	this->isValidChild = isValidChild;
	this->getChildren = getChildren;
	this->nNodes = nNodes;
}

SCC::~SCC() {
}

void SCC::calculateSCCs(vec<Var>& sccs){
	/*incomp.growTo((idsolver->*this->nNodes)(), false);
	visited.growTo(idsolver.nNodes(), 0); // =0 represents not visited; >0 corresponds to a unique value (the counter).
	counter = 1;
	for (int i=0; i<idsolver.nNodes(); i++){
		if (visited[i]==0){
			visit(i,sccs,incomp,stack,visited,counter);
		}
	}*/
}

/**
 * Executes the basic tarjan algorithm for finding strongly connected components (scc). It does this in the graph supplied by the instance
 * creator
 * @pre: only call it on defined nodes that are not already in a found scc
 * @post: root will be a partition that will be the exact partition of SCCs, by setting everything on the stack to the same root in the end
 * @post: the scc will be denoted by the variable in the scc which was visited first
 */
void SCC::visit(Var i, vec<Var> &root, vec<bool> &incomp, vec<Var> &stack, vec<Var> &visited, int& counter) {
	/*assert(!incomp[i]);
	visited[i] = ++counter;
	root[i] = i;
	stack.push(i);

	vec<Lit>& lits = getChildren();
	for (int j=0; j < lits.size(); ++j) {
		Var w = var(lits[j]);
		if (isValidChild(w)) {
			if (visited[w]==0){
				visit(w,root,incomp,stack,visited,counter);
			}
			if (!incomp[w] && visited[root[i]]>visited[root[w]]){
				root[i] = root[w];
			}
		}
	}

	if (root[i] == i) {
		int w;
		do {
			w = stack.last();
			stack.pop();
			root[w] = i; //these are the found sccs
			incomp[w] = true;
		} while (w != i);
	}*/
}
