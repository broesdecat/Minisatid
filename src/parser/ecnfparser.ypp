/*
 * Copyright 2007-2011 Katholieke Universiteit Leuven
 *
 * Use of this software is governed by the GNU LGPLv3.0 license
 *
 * Written by Broes De Cat and Maarten MariÃ«n, K.U.Leuven, Departement
 * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
 */
//%require "2.4.2"

//does not seem to have the same effect as adding it to the makefile
//%defines

//%skeleton "lalr1.cc"
//%language "c++"

//%code requires{
//temporarily, can just ensure that anytime the parser is included, vector etc has already been included.
%{
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <string>
#include <vector>
#include <list>
#include <map>

#include "external/ExternalUtils.hpp"
#include "external/ExternalInterface.hpp"
#include "external/FlatZincRewriter.hpp"
#include "external/Translator.hpp"
#include "utils/Print.hpp"

#include <limits>

using namespace MinisatID;
using namespace std;

typedef numeric_limits<int> intlim;

typedef WrappedSOSolver wsos;
typedef WrappedPCSolver wps;
typedef FlatZincRewriter wfz;

//}

//%code{
	
extern SolverOption modes;
extern Solution* sol;
FODOTTranslator*	fodottrans = NULL;
LParseTranslator*	simpletrans = NULL;
extern OUTPUTFORMAT transformat;
extern int 		yylex(void);
extern char * 	yytext;

void yyerror(const char* msg);
	
bool negatemod = false;
int cnfcurrentmodid = 0;
Atom cnfcurrenthead(-1);
std::vector<int> modalops;
std::vector<MinisatID::Literal> heads;

//Auxiliary variables, used while parsing.
int lineNo = 1;
int charPos = 1;

bool unsatfound = false;

wps*	solver = NULL;
wsos*	modsolver = NULL;
wfz* 	fzrewriter = NULL;

/**
 * CR-CheckResult: checks the result of passing some data to the solvers.
 * The result is false if unsat was already detected.
 */
template<class T>
void CR(int modid, const T& formula);
template<class T>
void CR(const T& formula);

void initSolver();
void initModSolver();

int atoms, clauses;

std::vector<MinisatID::Atom> rigidatoms; //a necessary list of accumulated rigid atoms when reading qbf format

void finishCNFHeader();
void readCNFModalHierLevel(bool existential, const std::vector<MinisatID::Atom>& rigidatoms);
pwls getData();
wfz* getFZRewriter();

MinisatID::Atom cAtom(string* c);
MinisatID::Literal cLiteral(string* c);
MinisatID::Weight cWeight(string* s);
int cID(string* c);

template<class T>
void addCPTo(WrappedPCSolver* solver, const T& formula);

// Convert integer to string
std::string itos(int n) {
   if(n == 0) return "0";
   std::string s;
	int a = abs(n);
   while(a > 0) {
      int temp = a % 10;
      char c = '0' + temp;
      s = c + s;
      a = (a - temp) / 10;
   }
	if(n < 0) return ('-' + s);
   else return s;
}

// Parsing

void addTuple(int literalnumber, const string& atom);
void parsetruelist(std::vector<int>* vi);
void parsearbitlist(std::vector<int>* vi);
void parsetype(std::string* name, std::vector<std::string>* inter);
void parsepred(std::string* name, int num, std::vector<std::string>* ptypes, bool f);

int defaultdefID = 1;
enum ECNF_VERSION {VERSION_NONE, VERSION_OLD, VERSION_NEW}; 
ECNF_VERSION currentreadversion = VERSION_NONE;

void checkVersion(ECNF_VERSION version);

%}

//for a reentrant parser, you need to use %pureparser

%union {
	int integer;
	bool boolean;
	const char* cstr;
	std::string* str;
    std::vector<int>* vints;
    std::vector<MinisatID::Weight>* vweights;
    std::vector<uint>* vuints;
    std::vector<MinisatID::Literal>* vlits;
    std::vector<MinisatID::WLtuple>* vlws;
    std::vector<MinisatID::Atom>* vatoms;
    MinisatID::EqType rel;
    MinisatID::AggType aggr;
    MinisatID::AggSign sign;
    MinisatID::AggSem sem;
    
	std::vector<std::string>*	vstr;
}

%token DEFOP EQUIV
%token SUBSETMINDEFN MNMZDEFN VARMINDEFN AGGMINDEFN
%token SETDEFN WSETDEFN  
%token <integer> ZERO
%token <str> NUMBER
%token <sem> SEMDEFN 
%token <sign> SIGNDEFN QUANTe
%token <rel> REL
%token <aggr> AGGDEFN
%token CNF ECNF MECNF DEFPRESENT AGGPRESENT MNMZPRESENT MODDEFN CPPRESENT
%token INTVAR INTVARDOM SUMSTSIRI COUNTSTRIT DISTINCT DELIM BINTRI BINTRT
%token FORCECHOICE

%type <integer> number
%type <str> weight
%type <vweights> weightbody
%type <vuints> uibody
%type <vlits> body
%type <vlws> wbody
%type <vatoms> vbody

//Translation
%token TRANSHEADER TRANSHEADER2
%token TYPE
%token PRED
%token FUNC
%token SHOWPRED
%token SHOWFUNC
%token TRUE
%token ARBIT

/** Other Terminals **/
%token <str> T_ID
%token <integer> T_NUM

/** Non-terminals with semantic value **/
%type <str>	identifier
%type <vints>	numlist
%type <vstr>	idlist
%type <vstr>	idnlist

//Blijkt nog niet te werken, zal ook wel in een nieuwere versie zijn
//%destructor { delete $$; report("DELETED.\n"); } vbody wbody ibody body

%start init

%%


/*
 * Decides whether to use (modal) CNF, ECNF or modal ECNF format
 */
init	:	CNF	number number 
				{ atoms = $2; clauses = $3; } 
			cnftheory
		|	ECNF header {initSolver();} ecnftheory translation
		|	MECNF header {initModSolver();} mecnftheory translation
		;

header	: 	/*empty*/
		| 	header DEFPRESENT
		| 	header CPPRESENT
		| 	header AGGPRESENT
		| 	header MNMZPRESENT
		;
		
// CNF THEORY
		
cnftheory	
		: 	modalcnf { finishCNFHeader(); } cnfclause
		;

modalcnf	
		:	/* empty */
		|	modalcnf QUANTe  
				{ 	readCNFModalHierLevel($2, rigidatoms); }
			rigidvars ZERO //HAS TO first add new level with PREVIOUS rigid atoms before adding to them
		;
		
rigidvars
 		:	rigidvars NUMBER	{ rigidatoms.push_back(cAtom($2));	delete $2; }
		|	NUMBER				{ rigidatoms.push_back(cAtom($1));	delete $1; }	
		;
			
cnfclause	
		: /*empty*/
		| 	cnfclause body ZERO	
			{	
				DisjunctionRef clause(*$2);
				if(modsolver!=NULL){
					CR(cnfcurrentmodid, clause);
				}else{
					CR(clause); 
				}
				delete $2;
			}
		;
			
//---------------------------------------------		
// ECNF THEORY	
//---------------------------------------------

ecnftheory	:	/* empty */
			|	ecnftheory FORCECHOICE body ZERO 
				{ 
					ForcedChoices choices;
					choices.forcedchoices = *$3;
					delete $3;
					solver->add(choices);  
				}
			|	ecnftheory clause
			|	ecnftheory equiv
			|	ecnftheory rule
			| 	ecnftheory agg
			|	ecnftheory set
			|	ecnftheory wset
			|	ecnftheory mnmz
			|	ecnftheory subsetmnmz
			|	ecnftheory varmnmz
			|	ecnftheory summnmz
			|	ecnftheory intvar
			|	ecnftheory cpconstraint
			;
			
mnmz	:	MNMZDEFN body ZERO
			{
				MinimizeOrderedList mnm;
				mnm.literals = *$2;
				delete $2;
				CR(mnm); 
			}
subsetmnmz: SUBSETMINDEFN body ZERO
			{ 
				MinimizeSubset mnm;
				mnm.literals = *$2;
				delete $2;
				CR(mnm); 
			}
varmnmz :	VARMINDEFN NUMBER ZERO
			{ 
				MinimizeVar mnm;
				mnm.varID = cID($2);
				CR(mnm);
			}

summnmz :	AGGMINDEFN AGGDEFN NUMBER NUMBER ZERO	
			{ 
				MinimizeAgg mnm;
				mnm.head = cAtom($3);
				mnm.setid = cID($4);
				mnm.type = $2;
				delete $3; delete $4;
				CR(mnm);
			}
		
clause	:	body ZERO	
			{
				Disjunction clause;
				clause.literals = *$1;
				delete $1;
				CR(clause);
			}
		;

equiv	:	EQUIV SEMDEFN NUMBER body ZERO
			{ 					
				Equivalence equiv;
				equiv.head = cLiteral($3);
				equiv.body = *$4;
				delete $3; delete $4;
				if($2==COMP){ //hack, to be fixed
					equiv.conjunctive = true;
				}else{
					equiv.conjunctive = false;
				}
				CR(equiv);
			}
		;

rule	:	SEMDEFN NUMBER body ZERO
			{ 	
				checkVersion(VERSION_OLD);
				
				Rule rule;
				rule.head = cAtom($2);
				rule.body = *$3;
				rule.definitionID = defaultdefID;
				delete $2; delete $3;
				if($1==COMP){ //hack, to be fixed
					rule.conjunctive = true;
				}else{
					rule.conjunctive = false;
				}
				CR(rule);
			}
		;

rule	:	SEMDEFN DEFOP NUMBER NUMBER body ZERO
			{ 	
				checkVersion(VERSION_NEW);
				
				Rule rule;
				rule.head = cAtom($4);
				rule.body = *$5;
				rule.definitionID = cID($3);
				delete $3; delete $4; delete $5;
				if($1==COMP){ //hack, to be fixedsetTruelist
					rule.conjunctive = true;
				}else{
					rule.conjunctive = false;
				}
				CR(rule);
			}
		;

agg		:	AGGDEFN SEMDEFN SIGNDEFN NUMBER NUMBER weight ZERO	
			{	
				if($2 == DEF){
					checkVersion(VERSION_OLD);
				}
	
				Aggregate agg;
				agg.head = cAtom($4);
				agg.setID = cID($5);
				agg.defID = defaultdefID;
				agg.bound = cWeight($6);
				agg.sign = $3;
				agg.type = $1;
				agg.sem = $2;
				delete $4; delete $5; delete $6;
				CR(agg);
			}
		;
agg		:	AGGDEFN DEFOP NUMBER SIGNDEFN NUMBER NUMBER weight ZERO	
			{	
				checkVersion(VERSION_NEW);

				Aggregate agg;
				agg.head = cAtom($5);
				agg.setID = cID($6);
				agg.defID = cID($3);
				agg.bound = cWeight($7);
				agg.sign = $4;
				agg.type = $1;
				agg.sem = DEF;
				delete $5; delete $6; delete $7;
				CR(agg);
			}
		;

set		:	SETDEFN NUMBER body ZERO	
			{ 	
				Set set;
				set.setID = cID($2);
				set.literals = *$3;
				delete $2; delete $3;
				CR(set);
			}
		;

wset	:	WSETDEFN NUMBER	wbody ZERO	
			{	
				WLSet set;
				set.setID = cID($2);
				set.wl = *$3;
				delete $2; delete $3;
				CR(set);
			}
		;

// ECNF CONSTRAINT SUPPORT

intvar	:	INTVAR number weight weight ZERO 
			{
				CPIntVarRange var;
				var.varID = $2;
				var.minvalue = cWeight($3);
				var.maxvalue = cWeight($4);
				CR(var);
				delete $3; delete $4;
			}
		|	INTVARDOM number weightbody DELIM ZERO 
			{
				CPIntVarEnum var;
				var.varID = $2;
				var.values = *$3;
				CR(var);
				delete $3;
			}
		;

//intvarset
//		:	INTVARSET number ibody ZERO 
//				{ 	CR(solver->addIntVarSet($2, *$3)); delete $3; }
//		;

//abbreviations: T = intterm, I = intconst, R = relational operator, ST = set of T, SI = set of I

cpconstraint
		:	BINTRI NUMBER number REL weight ZERO 
			{ 	
				CPBinaryRel binrel;
				binrel.head = cAtom($2);
				binrel.varID = $3;
				binrel.rel = $4;
				binrel.bound = cWeight($5);
				CR(binrel);
				delete $2; delete $5;
			}
		|	BINTRT NUMBER number REL number ZERO 
			{ 	
				CPBinaryRelVar binrel;
				binrel.head = cAtom($2);
				binrel.lhsvarID = $3;
				binrel.rel = $4;
				binrel.rhsvarID = $5;
				CR(binrel);
				delete $2;
			}
		|	SUMSTSIRI NUMBER uibody DELIM weightbody REL weight ZERO 
			{ 	
				CPSumWeighted sum;
				sum.head = cAtom($2);
				sum.varIDs = *$3;
				sum.weights = *$5;
				sum.rel = $6;
				sum.bound = cWeight($7);
				CR(sum);
				delete $2; delete $3; delete $5; delete $7;
			}
			//only global card at the moment!
		|	COUNTSTRIT uibody REL weight number ZERO 
			{ 	
				CPCount count;
				count.varIDs = *$2;
				count.rel = $3;
				count.eqbound = cWeight($4);
				count.rhsvar = $5;
				CR(count);
				delete $2; delete $4;
			}
			//only global alldiff at the moment!
		|	DISTINCT uibody DELIM ZERO //DELIM to remove shift-reduce conflict 
			{ 	
				CPAllDiff alldiff;
				alldiff.varIDs = *$2;
				CR(alldiff);
				delete $2;
			}
		;
			
//---------------------------------------------		
// MECNF THEORY	
//---------------------------------------------

mecnftheory	:	mhier mrest
			;

mhier	:	/* empty */
		|	mhier matomset
		|	mhier modhier
		;
		
mrest	: 	/* empty */
		|	mrest mclause
		|	mrest mrule
		| 	mrest magg
		|	mrest mset
		|	mrest mwset
		;
			
			
//MODAL PART: USES INDEXES+1 AS MODAL IDs IN THE THEORY
modhier :	MODDEFN	NUMBER NUMBER NUMBER ZERO 
			{
				SubTheory sub;
				sub.head = cLiteral($4);
				sub.child = cID($3)-1;
				delete $3; delete $4;
				CR(cID($2)-1, sub);
				delete $2; 
			}
		;

matomset:	QUANTe NUMBER vbody ZERO
			{ 
				if(!$1){
					throw idpexception("Forall quantifiers are not part of the chosen input format.\n");
				}
				RigidAtoms rigid;
				rigid.rigidatoms = *$3;
				delete $3;
				CR(cID($2)-1, rigid);
				delete $2; 
			}
		;

mclause	:	NUMBER body ZERO 
			{	
				Disjunction clause;
				clause.literals = *$2;
				delete $2;
				CR(cID($1)-1, clause); 
				delete $1;   
			}
		;

mrule	:	SEMDEFN NUMBER NUMBER body ZERO  
			{ 	
				checkVersion(VERSION_OLD);
				
				Rule rule;
				rule.head = cAtom($3);
				rule.body = *$4;
				rule.definitionID = defaultdefID;
				delete $2; delete $4;
				if($1==COMP){ //hack, to be fixed
					rule.conjunctive = true;
				}else{
					rule.conjunctive = false;
				}	
				CR(cID($2)-1, rule);		 
				delete $2;
			}
		;

mrule	:	SEMDEFN NUMBER DEFOP NUMBER NUMBER body ZERO
			{ 	
				checkVersion(VERSION_NEW);
				
				Rule rule;
				rule.head = cAtom($5);
				rule.body = *$6;
				rule.definitionID = cID($4);
				delete $4; delete $5; delete $6;
				if($1==COMP){ //hack, to be fixed
					rule.conjunctive = true;
				}else{
					rule.conjunctive = false;
				}		
				CR(cID($2)-1, rule);
			}
		;

magg	:	AGGDEFN  NUMBER SEMDEFN SIGNDEFN NUMBER NUMBER weight ZERO	
			{ 
				if($3==DEF){
					checkVersion(VERSION_OLD);
				}
				
				Aggregate agg;
				agg.head = cAtom($5);
				agg.setID = cID($6);
				agg.defID = defaultdefID;
				agg.bound = cWeight($7);
				agg.sign = $4;
				agg.type = $1;
				agg.sem = $3;
				delete $5; delete $6; delete $7;
				CR(cID($2)-1, agg);
				delete($2);
			}
		;

magg	:	AGGDEFN NUMBER DEFOP NUMBER SIGNDEFN NUMBER NUMBER weight ZERO	
			{	
				checkVersion(VERSION_NEW);

				Aggregate agg;
				agg.head = cAtom($6);
				agg.setID = cID($7);
				agg.defID = cID($4);
				agg.bound = cWeight($8);
				agg.sign = $5;
				agg.type = $1;
				agg.sem = DEF;
				delete $6; delete $7; delete $8;
				CR(cID($2)-1, agg);
			}
		;

mset	:	SETDEFN NUMBER NUMBER body ZERO	
			{ 	
				Set set;
				set.setID = cID($3);
				set.literals = *$4;
				delete $3; delete $4;
				CR(cID($2)-1, set);
				delete($2);
			}
		;

mwset	:	WSETDEFN NUMBER NUMBER wbody ZERO	
			{ 
				WLSet set;
				set.setID = cID($3);
				set.wl = *$4;
				delete $3; delete $4;
				CR(cID($2)-1, set);
				delete($2);
			}
		;


// TRANSLATION

translation	: /* empty */
			|	TRANSHEADER 
				{
					fodottrans = new FODOTTranslator(transformat);	
					if(fodottrans!=NULL){
						sol->setTranslator(fodottrans);
					}
				} 
				typelist predlist funclist truelist arbitlist
				
			| 	TRANSHEADER2 
				{	
					simpletrans = new LParseTranslator();				
					if(simpletrans!=NULL){
						sol->setTranslator(simpletrans);
					}
				}
				tuplelist
			;
			
typelist	: /* empty */
			| typelist type
			;
			
type		: TYPE identifier ':' idnlist	{ parsetype($2,$4); delete($2); delete($4);	}
			;

predlist	: /* empty */
			| predlist pred
			;

pred		: SHOWPRED T_NUM identifier ':' idlist	{ parsepred($3,$2,$5,false); delete($3); delete($5);	}
			| PRED T_NUM identifier ':' idlist		{ delete($3); delete($5);								}
			;

funclist	: /* empty */
			| funclist func
			;

func		: SHOWFUNC T_NUM identifier ':' idlist	{ parsepred($3,$2,$5,true); delete($3); delete($5); 	}
			| FUNC T_NUM identifier ':' idlist { delete($3); delete($5); }
			;

truelist	: TRUE ':' numlist	{ parsetruelist($3); delete($3); }
			;

arbitlist	: ARBIT ':' numlist	{ parsearbitlist($3); delete($3); }
			;

idnlist		: idnlist identifier	{ $1->push_back(*$2); $$ = $1; delete($2); }
			| idnlist T_NUM			{ $1->push_back(itos($2)); $$ = $1; }
			| identifier			{ $$ = new vector<string>(1,(*$1)); delete($1);	}
			| T_NUM					{ $$ = new vector<string>(1,itos($1)); }
			;

idlist		: /* empty */		{ $$ = new vector<string>(0); }
			| idlist identifier	{ $1->push_back(*$2); $$ = $1; delete($2); }
			;

numlist		: /* empty */		{ $$ = new vector<int>(0); }
			| numlist T_NUM		{ $1->push_back($2); $$ = $1; }
			| numlist identifier '/' T_NUM		{ $$ = $1; }
			| numlist identifier '/' T_NUM ':' { $$ = $1; }
			;
			
tuplelist	: /* empty */ 
			| tuplelist T_NUM identifier { addTuple($2, *$3); delete($3); }
			;

identifier	: T_ID	{ $$ = $1;	}
			;		

//---------------------------------------------		
// GENERAL RULES
//---------------------------------------------
			
//Clauses can be empty!
body	:	body NUMBER { $$ = $1; $$->push_back(cLiteral($2));	delete($2); }
		|				{ $$ = new std::vector<MinisatID::Literal>();	}
		;
		
wbody	:	wbody NUMBER REL 
			{ 
				if($3!=MinisatID::MEQ) { 
					throw MinisatID::idpexception("Weighted sets can only contain tuples with equality.\n");
				} 
			} 
			weight	
			{ $$ = $1; $$->push_back(MinisatID::WLtuple(cLiteral($2), cWeight($5))); delete($2);  delete $5;}
			
		|	NUMBER REL 
			{ 
				if($2!=MinisatID::MEQ) { 
					throw MinisatID::idpexception("Weighted sets can only contain tuples with equality.\n");
				} 
			} 
			weight	
			{ $$ = new std::vector<WLtuple>(1,MinisatID::WLtuple(cLiteral($1), cWeight($4))); delete($1); delete $4;}
		;
		
vbody	:	vbody NUMBER 	{ $$ = $1; $$->push_back(cAtom($2)); delete($2);	}
		|	NUMBER			{ $$ = new vector<Atom>(1,cAtom($1)); delete($1);	}	
		;
		
weightbody 	
		: 	weightbody weight	{ $$ = $1; $$->push_back(cWeight($2)); delete $2; }
		| 	weight			{ $$ = new vector<Weight>(1, cWeight($1)); delete $1;	}
		;
		
uibody 	: 	uibody number	{ $$ = $1; $$->push_back($2);	}
		| 	number  		{ $$ = new vector<uint>(1, $1);	}
		;
		
number	:	NUMBER	{ $$ = atoi((*$1).c_str()); delete($1); }
		|	ZERO	{ $$ = 0; }
		
weight	:	NUMBER	{ $$ = $1; }
		|	ZERO	{ $$ = new string("0"); }

%%

int yywrap() {
	cerr << "End of file reached before it was expected... bailing out.\n";
	return 1;
}

void yyinit(){ }

void yydestroy(){
	solver = NULL;
	modsolver = NULL;
	heads.clear();
	modalops.clear();
}

// If an unforeseen parse error occurs, it calls this function (e.g. with msg="syntax error")
//Should NOT be used any more: if an idpexception is thrown during parsing, even from deep within
//the code, the error handling will print the parsing position itself.
void yyerror(const char* msg) {
	throw idpexception(msg);
}

void checkVersion(ECNF_VERSION version){
	if(currentreadversion == VERSION_NONE){
		currentreadversion = version;
	}
	if(currentreadversion != version){
		throw idpexception("Cannot combine previous ecnf format with the new one "
				"(using rules/aggregates with and without definition id).\n");
	}
}

void initSolver(){
	if(modes.transformat==TRANS_FZ){
		fzrewriter = new FlatZincRewriter(modes);
	}else{
		solver = new WrappedPCSolver(modes);
	}
}

void initModSolver(){
	if(modes.transformat==TRANS_FZ){
		throw idpexception("Rewriting FO(MOD, .) into flatzinc is not supported yet.");
	}
	modsolver = new WrappedSOSolver(modes);
}

pwls getData(){
	if(solver!=NULL){
		return solver;
	}else{
		return modsolver;
	}
}

wfz* getFZRewriter(){
	return fzrewriter;
}

void readCNFModalHierLevel(bool existential, const vector<Atom>& rigidatoms){
	assert(solver==NULL);
	
	bool writeexists;
	if(existential && negatemod){
		negatemod = false;
		writeexists = false;
	}else if(existential && !negatemod){
		negatemod = false;
		writeexists = true;
	}else if(!existential && negatemod){
		negatemod = true;
		writeexists = true;
	}else{
		negatemod = true;
		writeexists = false;
	}
	if(modsolver==NULL){
		initModSolver();		 
		cnfcurrenthead = Atom(atoms+1);
	}else{
		modalops.push_back(cnfcurrentmodid);
		if(writeexists){
			heads.push_back(Literal(cnfcurrenthead, false));
		}else{
			heads.push_back(Literal(cnfcurrenthead, true));
		}
		cnfcurrentmodid++;
		SubTheory sub;
		sub.head = Literal(cnfcurrenthead);
		sub.child = cnfcurrentmodid;
		CR(cnfcurrentmodid-1, sub);
		RigidAtoms rigid;
		rigid.rigidatoms = rigidatoms;
		CR(cnfcurrentmodid, rigid);
		if(rigidatoms.size()==0){
			throw idpexception("List of rigid atoms is empty.\n");
		}
		cnfcurrenthead = Atom(cnfcurrenthead.getValue()+1);
	}
}

void finishCNFHeader(){
	if(modsolver==NULL && solver==NULL){ //plain cnf
		initSolver();
	}else{ //modal cnf
		if(negatemod){
			throw idpexception("The quantifiers require to negate the full theory, "
								"this is not handled at the moment.\n");
		}
		for(vector<int>::size_type i = 0; i<modalops.size(); ++i){
			Disjunction clause;
			clause.literals.push_back(heads[i]);
			CR(modalops[i], clause);	
		}
	}
}

Atom cAtom(string* c){
	int i = atoi(c->c_str());
	if(i<0){
		throw idpexception("Negative number supplied where an atom was suspected.\n");
	}
	return Atom(i);
}

int cID(string* c){
	int i = atoi(c->c_str());
	if(i<1){
		throw idpexception("IDs have to be non-negative nonzero integers.\n");
	}
	return i;
}

Literal cLiteral(string* c){
	int i = atoi(c->c_str());
	return Literal(abs(i), i<0);
}

Weight cWeight(string* s){
	const char* c = s->c_str();
	Weight w(0);
	bool begin = true, negate = false;
	for(int i = 0; c[i] != '\0'; ++i) {
	    if(begin && c[i]=='-'){
	    	negate = true;
	    	begin = false;
	    	continue;
	    }
#ifdef NOARBITPREC
		if(posInfinity()/10 < w){
			throw idpexception("Weight exceeds the maximum supported value. Consider using GMP.\n");
		}
#endif
	    w = w*10 + (c[i]-48);
	}
	if(negate){
		w *= -1;
	}
	return w;
}

/**
 * CR-CheckResult: checks the result of passing some data to the solvers.
 * The result is false if unsat was already detected.
 */
template<class T>
void CR(int modid, const T& formula){
	SATVAL result = modsolver->add(modid, formula);
	if(result==SATVAL::UNSAT){
		unsatfound = true;
		throw idpexception("Unsat during parsing.\n");
	}		
}
template<class T>
void CR(const T& formula){
	SATVAL result = SATVAL::POS_SAT;
	if(modes.transformat==TRANS_FZ){
		fzrewriter->add(formula);
	}else{
		result = solver->add(formula);
	}
	if(result==SATVAL::UNSAT){
		unsatfound = true;
		throw idpexception("Unsat during parsing.\n");
	}		
}

void addTuple(int literalnumber, const string& atom) {
	if(simpletrans!=NULL){
		simpletrans->addTuple(Atom(literalnumber), atom);
	}
}

void parsetruelist(vector<int>* literalnumbers) {
	if(fodottrans!=NULL){
		fodottrans->setTruelist(*literalnumbers);
	}
}

void parsearbitlist(vector<int>* literalnumbers) {
	if(fodottrans!=NULL){
		fodottrans->setArbitlist(*literalnumbers);
	}
}

void parsetype(string* name, vector<string>* inter) {
	if(fodottrans!=NULL){
		fodottrans->addType(*name, *inter);
	}
}

void parsepred(string* name, int startingnumber, vector<string>* argtypes, bool isfunction) {
	if(fodottrans!=NULL){
		fodottrans->addPred(*name, startingnumber, *argtypes, isfunction);
	}
}
