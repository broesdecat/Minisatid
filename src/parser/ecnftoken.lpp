%{
/* C++ declarations: */
#include <iostream>

/*
 * Temporarily, until new bison is available
 * SHOULD BE REMOVED THEN
 */
#include <vector>
#include "utils/Utils.hpp"
using namespace std; 
//UP TILL HERE!

#include "parser/ecnfparser.h"

extern int lineNo;
extern int charPos;

#define ADJ (charPos += yyleng)
%}

/* lex definitions: */
%option noyywrap
/*seems to be necessary to avoid windows problem with fileno function?*/
%option never-interactive 

%x TRANSLATION_MODUS
%%

^"c grounder error".*	{ throw MinisatID::idpexception("There was a grounding error, so no solving is possible.\n");}
^"c ".*		{/* disregard comments */}

^"p "	{ADJ; }
"cnf"	{ADJ; return CNF;}
"ecnf"	{ADJ; return ECNF;}
"mecnf"	{ADJ; return MECNF;}
"def" 	{ADJ; return DEFPRESENT;}
"aggr" 	{ADJ; return AGGPRESENT;}
"mnmz" 	{ADJ; return MNMZPRESENT;}
"cp" 	{ADJ; return CPPRESENT;}

"forcesearch" { ADJ; return FORCECHOICE; }

"WSet"	{ADJ; return WSETDEFN;}
"Set"	{ADJ; return SETDEFN;}
"Card"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::CARD; return AGGDEFN;}
"Sum"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::SUM; return AGGDEFN;}
"Prod"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::PROD; return AGGDEFN;}
"Min"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::MIN; return AGGDEFN;}
"Max"	{ADJ; /*ecnflval*/yylval.aggr = MinisatID::MAX; return AGGDEFN;}

^"Mod"	{ADJ; return MODDEFN;}

"D"		{ADJ; /*ecnflval*/yylval.sem = MinisatID::DEF;  return SEMDEFN;}
"C"		{ADJ; /*ecnflval*/yylval.sem = MinisatID::COMP; return SEMDEFN;}
"L"		{ADJ; /*ecnflval*/yylval.sign = MinisatID::AGGSIGN_UB; return SIGNDEFN;}
"G"		{ADJ; /*ecnflval*/yylval.sign = MinisatID::AGGSIGN_LB; return SIGNDEFN;}

^"e"	{ADJ; /*ecnflval*/yylval.boolean = true; return QUANTe;} //existential quantifier
^"a"	{ADJ; /*ecnflval*/yylval.boolean = false; return QUANTe;} //universal quantifier

^"Mnmz"		{ADJ; return SUBSETMINDEFN;}
^"Mnmt"     {ADJ; return MNMZDEFN;}
^"SumMnmz"	{ADJ; return SUMMINDEFN;}

" "		{ADJ; /* disregard whitespaces */}
"\t"	{ADJ; /*                       */}
"\n"	{charPos = 1; lineNo++; /*     */}

"|"	{ADJ; return DELIM;}

^"INTVAR"	{ADJ; return INTVAR;}
^"BINTRI"	{ADJ; return BINTRI;}
^"BINTRT"	{ADJ; return BINTRT;}
^"SUMSTRI"	{ADJ; return SUMSTRI;}
^"SUMSTRT"	{ADJ; return SUMSTRT;}
^"SUMSTSIRI"	{ADJ; return SUMSTSIRI;}
^"SUMSTSIRT"	{ADJ; return SUMSTSIRT;}
^"COUNTSTRIT"	{ADJ; return COUNTSTRIT;}

"="		{ADJ; /*ecnflval*/yylval.rel = MinisatID::MEQ; return REL;}
">"		{ADJ; /*ecnflval*/yylval.rel = MinisatID::MG; return REL;}
"<"		{ADJ; /*ecnflval*/yylval.rel = MinisatID::ML; return REL;}
"~="	{ADJ; /*ecnflval*/yylval.rel = MinisatID::MNEQ; return REL;}
"=<"	{ADJ; /*ecnflval*/yylval.rel = MinisatID::MLEQ; return REL;}
">="	{ADJ; /*ecnflval*/yylval.rel = MinisatID::MGEQ; return REL;}

^"translation"	{ ADJ; return TRANSHEADER;		}
^"type"			{ ADJ; return TYPE;				}
^"show pred"	{ ADJ; return SHOWPRED;			}
^"pred"			{ ADJ; return PRED;				}
^"show func"	{ ADJ; return SHOWFUNC;			}
^"func"			{ ADJ; return FUNC;				}
^"true"			{ ADJ; return TRUE;				}
^"arbitrary"	{ ADJ; return ARBIT;			}
_*[A-Za-z][a-zA-Z0-9_]*	{ ADJ;
						/*ecnflval*/yylval.str = new string(yytext);
						return IDENTIFIER; }
":"				{ ADJ; return *yytext; }

 /* Longest match is returned -> if e.g. "20", NUMBER is returned.
	If "0", then ZERO is returned since it's the first matching rule.
 */
"0"			{ADJ; /*ecnflval*/yylval.integer = 0; return ZERO;}
-?[0-9]+	{ADJ;
			/*ecnflval*/yylval.str = new string(yytext); return NUMBER;}

<*>.		{/* Anything else: parse error */
				char s[100];
				sprintf(s, "Encountered unexpected character '%s'.\n", yytext);
				throw MinisatID::idpexception(s);
			}
